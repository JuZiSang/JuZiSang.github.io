{"meta":{"title":"橘子的Blog","subtitle":"Blog","description":"记录一些知识","author":"juzisang","url":"https://www.juzisang.com"},"pages":[{"title":"categories","date":"2019-02-10T08:57:05.732Z","updated":"2019-02-10T08:57:05.732Z","comments":true,"path":"categories/index.html","permalink":"https://www.juzisang.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-02-10T08:59:09.888Z","updated":"2019-02-10T08:59:09.888Z","comments":true,"path":"friends/index.html","permalink":"https://www.juzisang.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-10T08:57:05.732Z","updated":"2019-02-10T08:57:05.732Z","comments":true,"path":"tags/index.html","permalink":"https://www.juzisang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于 CORS，你需要知道的","slug":"关于CORS，你需要知道的","date":"2019-02-09T16:00:00.000Z","updated":"2019-02-16T09:35:35.907Z","comments":true,"path":"passages/关于CORS，你需要知道的/","link":"","permalink":"https://www.juzisang.com/passages/关于CORS，你需要知道的/","excerpt":"CORS 全称 Cross-origin resource sharing（跨域资源共享） 用来解决浏览器跨域的其中一个方案 使用 Ajax 发起一个请求，如果这个请求的协议、域名、端口只要有一个与当前文档所处的地址不同，就会出现报错。","text":"CORS 全称 Cross-origin resource sharing（跨域资源共享） 用来解决浏览器跨域的其中一个方案 使用 Ajax 发起一个请求，如果这个请求的协议、域名、端口只要有一个与当前文档所处的地址不同，就会出现报错。 CORS 全称 Cross-origin resource sharing（跨域资源共享） 用来解决浏览器跨域的其中一个方案 什么时候需要CORS 使用 Ajax 发起一个请求，如果这个请求的协议、域名、端口只要有一个与当前文档所处的地址不同，就会出现报错。 而为了解决这个问题，就需要用到 CORS 具体可以阅读浏览器的同源策略 怎么使用CORS 只需要服务器在请求，响应头里增加 12345// 允许制定域名访问，注意协议、域名、端口要写全Access-Control-Allow-Origin:https://www.juzisang,com// 允许所有域名访问Access-Control-Allow-Origin:* 请求分类 请求分为两种，简单请求、复杂请求，如果我们只设置了上面一个响应头，那么只允许发起简单请求 简单请求 允许的方法：GET、HEAD、POST 允许的请求头 Accept Accept-Language Content-Language Content-Type 更多… Content-Type text/plain multipart/form-data application/x-www-form-urlencoded 复杂请求 使用了简单请求以外的 Http 方法或者请求头，浏览器将会发起一个 OPTIONS 预请求。 如果服务器没有返回对应的信息，将会报如下错误 添加简单请求以外的请求头 使用简单请求以外的方法 发起复杂请求 工作主要集中在服务端，需要服务端在响应中返回对应的响应头，允许我们添加这些属性，及使用这些方法 允许 Http 方法 12345// 允许指定方法，逗号隔开&quot;Access-Control-Allow-Methods&quot;: &quot;PUT,DELETE,GET,POST&quot;// 允许所有方法&quot;Access-Control-Allow-Headers&quot;: &quot;*&quot; 允许自定义请求头 12// 允许指定请求头，逗号隔开&quot;Access-Control-Allow-Headers&quot;: &quot;XXX,Authorization&quot; 允许传输 Cookie 12// 设置为 true 允许Access-Control-Allow-Credentials:true OPTIONS 方法间隔时间 如果没有设置这个头，每次请求都会发起 OPTIONS 12// 第二次请求，间隔直接在 1000 秒之内，不在发起 OPTIONS 请求&quot;Access-Control-Max-Age&quot;: 1000 允许客户端可以读取的响应头 12345// 允许客户端读取 XXX,CHeaderAccess-Control-Expose-Headers:&quot;XXX,CHeader&quot;// 允许所有响应头可被读取Access-Control-Expose-Headers:&quot;*&quot; 代码 上面演示实例及报错实例在这里","categories":[{"name":"Web","slug":"Web","permalink":"https://www.juzisang.com/categories/Web/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.juzisang.com/tags/Http/"},{"name":"Web","slug":"Web","permalink":"https://www.juzisang.com/tags/Web/"}]},{"title":"改造 VueCli3，支持 TSX","slug":"改造VueCli3，支持TSX","date":"2018-12-09T16:00:00.000Z","updated":"2019-02-16T09:36:55.409Z","comments":true,"path":"passages/改造VueCli3，支持TSX/","link":"","permalink":"https://www.juzisang.com/passages/改造VueCli3，支持TSX/","excerpt":"Vue-Cli3 中虽然提供了 TypeScript 写 Vue，但是由于插件的支持度不够，Vue 文件里写 Ts，体验貌似也没什么提升，所以，我决定使用 TSX 来写 Vue 接下来，我以 Vue 初始项目为例，演示怎么将 Vue 文件转换成 Tsx","text":"Vue-Cli3 中虽然提供了 TypeScript 写 Vue，但是由于插件的支持度不够，Vue 文件里写 Ts，体验貌似也没什么提升，所以，我决定使用 TSX 来写 Vue 接下来，我以 Vue 初始项目为例，演示怎么将 Vue 文件转换成 Tsx Vue-Cli3 中虽然提供了 TypeScript 写 Vue，但是由于插件的支持度不够，Vue 文件里写 Ts，体验貌似也没什么提升，所以，我决定使用 TSX 来写 Vue 接下来，我以 Vue 初始项目为例，演示怎么将 Vue 文件转换成 Tsx 新建项目 我们使用 Vue-Cli3 新建一个项目，配置如下 vue-tsx-support 增强提示 1yarn add vue-tsx-support -D 专门为了 Vue Tsx 文件，而编写的一个依赖，详细请阅读官网 或者参考我的项目里 https://github.com/JuZiSang/blog 的用法 Tsx 热重置 所需依赖 1yarn add vue-jsx-hot-loader -D vue.config.js 在 chainWebpack 增加如下 loader，支持热重置 123456config.module .rule(\"tsx\") .test(/\\.tsx$/) .use(\"vue-jsx-hot-loader\") .before(\"babel-loader\") .loader(\"vue-jsx-hot-loader\"); CSSModule 支持 在 Tsx 中，Vue 原来的 scoped 方案就失效了，所以我决定使用 css-module 解决这个问题，并且配合 typings-for-css-modules-loader 生成 *.d.ts 增加提示 依赖 1yarn add typings-for-css-modules-loader node-sass sass-loader -D vue.config.js 123456789[\"css\", \"less\", \"scss\", \"sass\", \"stylus\", \"postcss\"].forEach(rule =&gt; &#123; // rules for *.module.* files // 将 css-loader 替换为 typings-for-css-modules-loader const cssRule = config.module .rule(rule) .oneOf(\"normal-modules\") .uses.get(\"css-loader\") .set(\"loader\", \"typings-for-css-modules-loader\");&#125;); 我们可以继续在 vue.config.js 的 css 选项中配置我们的 css，详情戳这里 123456789101112&#123; loaderOptions: &#123; css: &#123; // name 导出 namedExport: true, // 是否使用驼峰 camelCase: true, // html 中 实际的 css 类名 localIdentName: process.env.NODE_ENV !== \"production\" ? \"[local]-[hash:base64:5]\" : \"[hash:base64:5]\" &#125; &#125;&#125;; 支持 sync v-model 依赖 1yarn add babel-plugin-jsx-v-model babel-plugin-vue-jsx-sync -D babel.config.js 1234module.exports = &#123; presets: [\"@vue/app\"], plugins: [\"vue-jsx-sync\", \"jsx-v-model\"]&#125;; 总结 1yarn add vue-tsx-support vue-jsx-hot-loader typings-for-css-modules-loader node-sass sass-loader babel-plugin-jsx-v-model babel-plugin-vue-jsx-sync -D 经过如上改造，就能愉快的编写 Tsx 了 源码地址","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.juzisang.com/categories/Vue/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.juzisang.com/tags/Web/"},{"name":"Vue","slug":"Vue","permalink":"https://www.juzisang.com/tags/Vue/"}]},{"title":"Centos7下Guacamole安装配置","slug":"Centos7下Guacamole安装配置","date":"2017-09-22T16:00:00.000Z","updated":"2019-02-10T10:05:44.099Z","comments":true,"path":"passages/Centos7下Guacamole安装配置/","link":"","permalink":"https://www.juzisang.com/passages/Centos7下Guacamole安装配置/","excerpt":"Guacamole 是一个提供远程桌面解决方案的开源项目，通过浏览器就能操作虚拟机，适用于 Chrome、Firefox、IE9+ 等浏览器（浏览器需要支持 HTML5）。只要在一个服务器成功安装 Guancamole，就可以通过访问一个 web 浏览器去操作我们配置好的虚拟机。当然，作为一个开源的项目，我们可以对 Guacamole 做相应的定制修改，使其适配我们的项目需求，比如做成自动登录的，加上项目权限验证等。","text":"Guacamole 是一个提供远程桌面解决方案的开源项目，通过浏览器就能操作虚拟机，适用于 Chrome、Firefox、IE9+ 等浏览器（浏览器需要支持 HTML5）。只要在一个服务器成功安装 Guancamole，就可以通过访问一个 web 浏览器去操作我们配置好的虚拟机。当然，作为一个开源的项目，我们可以对 Guacamole 做相应的定制修改，使其适配我们的项目需求，比如做成自动登录的，加上项目权限验证等。 一、介绍 Guacamole 是一个提供远程桌面解决方案的开源项目，通过浏览器就能操作虚拟机，适用于 Chrome、Firefox、IE9+ 等浏览器（浏览器需要支持 HTML5）。只要在一个服务器成功安装 Guancamole，就可以通过访问一个 web 浏览器去操作我们配置好的虚拟机。当然，作为一个开源的项目，我们可以对 Guacamole 做相应的定制修改，使其适配我们的项目需求，比如做成自动登录的，加上项目权限验证等。 二、准备 Centos7 x86-64 JDK8 Tomcat7 Guacamole 服务器：guacamole-server-0.9.9.tar.gz Guacamole 客户端：guacamole-0.9.9.war 三、JDK 安装 12yum updateyum install java 四、安装 Tomcat 12345678910111213141516# 创建用户组groupadd tomcatuseradd -s /bin/bash -g tomcat tomcat# 下载Tomcatyum install wgetwget https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.9/bin/apache-tomcat-8.5.9.tar.gztar -zxvf apache-tomcat-8.5.9.tar.gzmv apache-tomcat-8.5.9 tomcatmv ./tomcat /usr/local/# 修改权限chown -R tomcat:tomcat /usr/local/tomcat# 启动/usr/local/tomcat/bin/startup.sh 配置为系统服务 12345678910111213141516171819202122232425262728293031323334# catalina.sh 移动到init.d目录，并重命名tomcatcp /usr/local/tomcat/bin/catalina.sh /etc/init.dmv /etc/init.d/catalina.sh /etc/init.d/tomcat# 修改comcat文件，并将这段的代码加入其中vi /etc/init.d/tomcat#chkconfig:2345 10 90#description:Tomcat service# java和tomcat安装路径CATALINA_HOME=/usr/local/apache-tomcat-8.5.9JAVA_HOME=/usr/local/jdk1.8.0_111# 修改权限chmod +x /etc/init.d/tomcat# 加入服务列表chkconfig --add tomcat# 检查是否加入列表chkconfig --list tomcat# 测试tomcat服务service tomcat# 常用操作service tomcat startservice tomcat stop# 将tomcat加入到环境变量中vi /etc/profile# 末尾加入export CATALINA_HOME=/usr/local/tomcat# 刷新source /etc/profile 五、安装 Guacamole 服务端 1234567891011121314151617181920212223# 安装依赖yum install -y cairo cairo-devel libpng libpng-devel freerdp freerdp-devel pango pango-devel libssh2 libssh2-devel libtelnet libtelnet-devel libvncserver libvncserver-devel pulseaudio pulseaudio-libs pulseaudio-libs-devel openssl cd openssl-devel libvorbis libvorbis-devel uuid uuid-devel gcc libjpeg-turbo-devel# 编译安装wget http://ncu.dl.sourceforge.net/project/guacamole/current/source/guacamole-server-0.9.9.tar.gztar -xvzf guacamole-server-0.9.9.tar.gzcd guacamole-server-0.9.9/./configure --with-init-dir=/etc/init.dmakemake installldconfig# 配置guacamole服务chown root.root /etc/init.d/guacdchmod 755 /etc/init.d/guacdchkconfig --add guacdchkconfig guacd on# 常用命令service guacd startservice guacd stopservice guacd restartservice guacd status 六、安装 Guacamole 客户端 配置文件 创建配置文件 12345mkdir /etc/guacamolemkdir /root/.guacamoletouch /etc/guacamole/guacamole.propertiestouch /etc/guacamole/user-mapping.xmlln -s /etc/guacamole/guacamole.properties /root/.guacamole/ guacamole.properties 12# 配置基本用户映射basic-user-mapping: /etc/guacamole/user-mapping.xml user-mapping.xml 12345678910111213141516171819202122232425262728&lt;user-mapping&gt; &lt;authorize username=\"juzisang\" password=\"juzisang\"&gt; &lt;connection name=\"Windows10\"&gt; &lt;protocol&gt;rdp&lt;/protocol&gt; &lt;!-- 加密方式 --&gt; &lt;param name=\"security\"&gt;nla&lt;/param&gt; &lt;param name=\"hostname\"&gt;10.1.48.141&lt;/param&gt; &lt;param name=\"port\"&gt;3389&lt;/param&gt; &lt;!-- 屏幕渲染色值 --&gt; &lt;param name=\"color-depth\"&gt;24&lt;/param&gt; &lt;!-- 用户名密码在nla加密下必须输入 --&gt; &lt;param name=\"username\"&gt;username&lt;/param&gt; &lt;param name=\"password\"&gt;password&lt;/param&gt; &lt;!-- 忽略证书 --&gt; &lt;param name=\"ignore-cert\"&gt;true&lt;/param&gt; &lt;/connection&gt; &lt;connection name=\"Windows10 JuZi\"&gt; &lt;protocol&gt;rdp&lt;/protocol&gt; &lt;param name=\"security\"&gt;nla&lt;/param&gt; &lt;param name=\"hostname\"&gt;192.168.0.125&lt;/param&gt; &lt;param name=\"port\"&gt;3389&lt;/param&gt; &lt;param name=\"color-depth\"&gt;24&lt;/param&gt; &lt;param name=\"username\"&gt;username&lt;/param&gt; &lt;param name=\"password\"&gt;password&lt;/param&gt; &lt;param name=\"ignore-cert\"&gt;true&lt;/param&gt; &lt;/connection&gt; &lt;/authorize&gt;&lt;/user-mapping&gt; 添加进环境变量 12345vi /etc/profile# 末尾添加export GUACAMOLE_HOME=/etc/guacamole# 刷新source /etc/profile 客户端网页下载和安装 12345678wget http://downloads.sourceforge.net/project/guacamole/current/binary/guacamole-0.9.9.war# 移动至 Tomact webapps 目录mv guacamole-0.9.9.war /usr/local/tomcat/webapps/guacamole.war# 重启 Tomcatservice tomcat stopservice tomcat start 七、遇到问题 编译失败 缺少gcc libjpeg-turbo-devel这两个库，安装即可 1yum install -y gcc libjpeg-turbo-devel RDP 连接 win10 老是断开 guacamole 默认的 RDP 为标准协议，更改为 nla 加密协议解决问题， 注意：nla 加密下，username，password 必须填写 1&lt;param name=\"security\"&gt;nla&lt;/param&gt;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.juzisang.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.juzisang.com/tags/Linux/"},{"name":"Guacamole","slug":"Guacamole","permalink":"https://www.juzisang.com/tags/Guacamole/"}]},{"title":"群晖使用Frp实现内网穿透","slug":"群晖使用Frp实现内网穿透","date":"2017-08-19T16:00:00.000Z","updated":"2019-02-10T10:07:36.754Z","comments":true,"path":"passages/群晖使用Frp实现内网穿透/","link":"","permalink":"https://www.juzisang.com/passages/群晖使用Frp实现内网穿透/","excerpt":"准备 群晖 拥有外网 ip 的 vps frp 域名（不是必须，你也可以用 ip 来访问）","text":"准备 群晖 拥有外网 ip 的 vps frp 域名（不是必须，你也可以用 ip 来访问） 一、准备 群晖 拥有外网 ip 的 vps frp 域名（不是必须，你也可以用 ip 来访问） 二、VPS 设置 下载 Frp 我这是使用的是 64 位的 ubuntu 系统的，如果需要其他的，请自行在 Github 上下载对应的版本 12345678// 下载wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz// 解压tar -zxvf frp_0.13.0_linux_amd64.tar.gz// 进去frp目录cd frp_0.13.0_linux_amd64// 删除不需要的文件rm -rf frpc frpc.ini frpc_full.ini Frps 配置 1234567891011121314151617181920212223242526272829303132[common]bind_port = 7000max_pool_count = 5authentication_timeout = 900# 管理端 进入frp自带的web管理界面的帐号密码dashboard_port = 7500dashboard_user = userdashboard_pwd = pwd# ssh端口 auth_token就是密钥，随便填个[ssh]listen_port = 6000auth_token = token# 群晖网页[dms]listen_port = 5000auth_token = token# 群晖[cloud_station]listen_port = 6690auth_token = token[ds_photo]listen_port = 8080auth_token = token# 域名# vhost_http_port = 80# subdomain_host = juzisang.com 启动 1./frps -c ./frps.ini 三、群晖配置 开启 ssh ssh 进入群晖 1234// ssh进入群晖ssh juzisang@群晖局域网ip// 切换root用户sudo -s 下载 Frp 12345678// 下载wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz// 解压tar -zxvf frp_0.13.0_linux_amd64.tar.gz// 进去frp目录cd frp_0.13.0_linux_amd64// 删除不需要的文件rm -rf frps frps.ini frps_full.ini Frpc 配置 1234567891011121314151617181920212223242526272829303132333435363738[common]server_addr = xx.xx.xx.xxserver_port = 7000// frps中填的auth_token = tokenpool_count = 1# ssh[ssh]type = tcp// 群晖局域网iplocal_ip = 192.168.31.50// 本地端口local_port = 22// 穿透到vps中的端口remote_port = 6000# 群晖网页[dms]type = tcplocal_ip = 192.168.31.50local_port = 5000remote_port = 5000# subdomain = nas# 群晖同步[cloud_station]type = tcplocal_ip = 192.168.31.50local_port = 6690remote_port = 6690# 群晖照片[ds_photo]type = tcplocal_ip = 192.168.31.50local_port = 80remote_port = 8080 启动 1./frps -c ./frps.ini 四、后台运行 服务端 1nohup ./frps -c ./frps.ini &amp; 客户端 1nohup ./frpc -c ./frpc.ini &amp;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.juzisang.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.juzisang.com/tags/Linux/"},{"name":"Frp","slug":"Frp","permalink":"https://www.juzisang.com/tags/Frp/"},{"name":"群晖","slug":"群晖","permalink":"https://www.juzisang.com/tags/群晖/"}]},{"title":"自定义九宫格手势解锁","slug":"自定义九宫格手势解锁","date":"2016-04-25T16:00:00.000Z","updated":"2019-02-10T10:06:56.725Z","comments":true,"path":"passages/自定义九宫格手势解锁/","link":"","permalink":"https://www.juzisang.com/passages/自定义九宫格手势解锁/","excerpt":"项目中用到手势解锁，然而没有在 GitHub 上找到想要的样式= =，只好自己来定义了，下面来看代码~~ 基本上很多应用的手势解锁全都是九宫格的，内部内就是九个小圈圈而已。那么我们就先来自定义这个小圈圈吧~","text":"项目中用到手势解锁，然而没有在 GitHub 上找到想要的样式= =，只好自己来定义了，下面来看代码~~ 基本上很多应用的手势解锁全都是九宫格的，内部内就是九个小圈圈而已。那么我们就先来自定义这个小圈圈吧~ 项目中用到手势解锁，然而没有在 GitHub 上找到想要的样式= =，只好自己来定义了，下面来看代码~~ 基本上很多应用的手势解锁全都是九宫格的，内部内就是九个小圈圈而已。那么我们就先来自定义这个小圈圈吧~ 一、状态 圈圈的颜色选择状态有大致有三种状态，所以我定义了一个枚举来区分 12345678910package com.juzisang.com.library;/** * Created by 橘子桑 on 2016/3/27. */public enum LockState &#123; SELECT_STATE,//选中 ERRER_STATE, //错误 DEFAULT_COLOR //默认&#125; 二、圆圈 View 圈圈分为边框，内部填充色，还有内部圆。所以我定义了三个画笔来区分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.juzisang.com.library;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.view.View;/** * Created by 橘子桑 on 2016/3/27. */public class MarkerView extends View &#123; //是否显示内部的圈圈 private boolean mInsideNodeShow; //宽度 protected int mContentWidth; //宽度 protected int mContentRadius; //选中状态 protected LockState mCurrentState = LockState.DEFAULT_COLOR; //画边框画圆的的画笔 private Paint mNodeFramePaint; private Paint mNodeCirclePaint; private Paint mNodeFullPaint; //默认的颜色 private int mDefaultColor = Color.parseColor(\"#757575\"); private int mDefailtFullColor = Color.parseColor(\"#64757575\"); private int mNodeDefaultColor = Color.parseColor(\"#757575\"); //选中的颜色 private int mSelectColor = Color.parseColor(\"#7ECEF4\"); private int mFrameSelectFullColor = Color.parseColor(\"#647ECEF4\"); private int mNodeSelectColor = Color.parseColor(\"#7ECEF4\"); //错误时候的颜色 private int mErrerColor = Color.parseColor(\"#EC6941\"); private int mErrerFullColor = Color.parseColor(\"#64EC6941\"); private int mErrerNodeColor = Color.parseColor(\"#EC6941\"); //边框的宽度 private int mFrameLineWidth; private int mNodeRadius; //每个圈圈的内边距 private int mNodePadding; //触摸有效的范围 private float mTouchRatio; //当前标记的位置 private int mNum; public MarkerView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(context, attrs, 0); &#125; public MarkerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(context, attrs, defStyleAttr); &#125; //以后外部布局传来的参数 public MarkerView(Context context, int mDefaultColor, int mDefailtFullColor, int mNodeDefaultColor, int mSelectColor, int mFrameSelectFullColor, int mNodeSelectColor, int mErrerColor, int mErrerFullColor, int mErrerNodeColor, int mFrameLineWidth, int mNodeRadius, int mNodePadding, boolean insideNodeShow) &#123; super(context); this.mInsideNodeShow = insideNodeShow; this.mDefaultColor = mDefaultColor; this.mDefailtFullColor = mDefailtFullColor; this.mNodeDefaultColor = mNodeDefaultColor; this.mSelectColor = mSelectColor; this.mFrameSelectFullColor = mFrameSelectFullColor; this.mNodeSelectColor = mNodeSelectColor; this.mErrerColor = mErrerColor; this.mErrerFullColor = mErrerFullColor; this.mErrerNodeColor = mErrerNodeColor; this.mFrameLineWidth = mFrameLineWidth; this.mNodeRadius = mNodeRadius; this.mNodePadding = mNodePadding; //内边距 setPadding(mNodePadding, mNodePadding, mNodePadding, mNodePadding); //外部圆 mNodeFramePaint = new Paint(); mNodeFramePaint.setColor(mDefaultColor); mNodeFramePaint.setAntiAlias(true); mNodeFramePaint.setStrokeWidth(mFrameLineWidth); mNodeFramePaint.setStyle(Paint.Style.STROKE);//只画出边框 //内部填充色 mNodeFullPaint = new Paint(); mNodeFullPaint.setColor(mDefailtFullColor); mNodeFullPaint.setStyle(Paint.Style.FILL); mNodeFullPaint.setAntiAlias(true); //内部圆 mNodeCirclePaint = new Paint(); mNodeCirclePaint.setColor(mNodeDefaultColor); mNodeCirclePaint.setStyle(Paint.Style.FILL);//填充 mNodeCirclePaint.setAntiAlias(true); &#125; //取当前透明度的百分比 public int getFullAlpha(int color, float ratio) &#123; return Color.argb((int) (Color.alpha(color) * ratio), Color.red(color), Color.green(color), Color.blue(color)); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mContentWidth = getWidth(); mContentRadius = mContentWidth / 2 - Math.abs(getPaddingLeft()) - mFrameLineWidth / 2; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); switch (mCurrentState) &#123; case DEFAULT_COLOR: //默认 mNodeFramePaint.setColor(mDefaultColor); mNodeFullPaint.setColor(mDefailtFullColor); mNodeCirclePaint.setColor(mNodeDefaultColor); //外圆 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius, mNodeFramePaint); //填充色 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius - mFrameLineWidth / 2, mNodeFullPaint); //中心圆 if (mInsideNodeShow) canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mNodeRadius, mNodeCirclePaint); break; case ERRER_STATE://错误 mNodeFramePaint.setColor(mErrerColor); mNodeFullPaint.setColor(mErrerFullColor); mNodeCirclePaint.setColor(mErrerNodeColor); //外圆 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius, mNodeFramePaint); //填充色 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius - mFrameLineWidth / 2, mNodeFullPaint); //中心圆 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mNodeRadius, mNodeCirclePaint); break; case SELECT_STATE://选中 mNodeFramePaint.setColor(mSelectColor); mNodeFullPaint.setColor(mFrameSelectFullColor); mNodeCirclePaint.setColor(mNodeSelectColor); //外圆 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius, mNodeFramePaint); //填充色 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mContentRadius - mFrameLineWidth / 2, mNodeFullPaint); //中心圆 canvas.drawCircle(mContentWidth / 2, mContentWidth / 2, mNodeRadius, mNodeCirclePaint); break; &#125; &#125; //设置状态，并且重绘 public void setState(LockState CurrentState) &#123; mCurrentState = CurrentState; invalidate(); &#125; //是否选中 public boolean isHighLighted() &#123; if (mCurrentState == LockState.SELECT_STATE || mCurrentState == LockState.ERRER_STATE) &#123; return true; &#125; return false; &#125; //中心点X public int getCenterX() &#123; return (getLeft() + getRight()) / 2; &#125; //中心点Y public int getCenterY() &#123; return (getTop() + getBottom()) / 2; &#125; //设置圈圈在手势锁当中的位置 protected void setNum(int num) &#123; mNum = num; &#125; protected int getNum() &#123; return mNum; &#125;&#125; 以上就是一个简单的圆了 三、自定义九宫格 View 属性 那么，自定义 View 当然会有自定义属性，所以有这么多 T0T，不要问我为什么这么多属性，任性= =（其实我还想写更多），自定义属性的方法 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 线的颜色 --&gt; &lt;attr name=\"lineColor\" format=\"color\" /&gt; &lt;!-- 线的宽度 --&gt; &lt;attr name=\"lineWidth\" format=\"dimension\" /&gt; &lt;!--默认颜色 --&gt; &lt;attr name=\"defaultColor\" format=\"color\" /&gt; &lt;!--默认时的填充色--&gt; &lt;attr name=\"defaultFullColor\" format=\"color\" /&gt; &lt;!--默认内部圆颜色--&gt; &lt;attr name=\"defaultNodeColor\" format=\"color\" /&gt; &lt;!-- ======================================================= --&gt; &lt;!-- 边框选中时边框的颜色 --&gt; &lt;attr name=\"selectColor\" format=\"color\" /&gt; &lt;!-- 边框选中时内部的填充色 --&gt; &lt;attr name=\"selectFrameFullColor\" format=\"color\" /&gt; &lt;!--内部圆圈选中时的颜色--&gt; &lt;attr name=\"selectNodeColor\" format=\"color\" /&gt; &lt;!-- ======================================================= --&gt; &lt;!-- 错误的颜色 --&gt; &lt;attr name=\"errorColor\" format=\"color\" /&gt; &lt;!--错误时内部的填充色--&gt; &lt;attr name=\"errorFullColor\" format=\"color\" /&gt; &lt;!-- 错误时的颜色 --&gt; &lt;attr name=\"errorNodeColor\" format=\"color\" /&gt; &lt;!-- ======================================================= --&gt; &lt;!--边框的的宽度--&gt; &lt;attr name=\"frameLineWidth\" format=\"dimension\" /&gt; &lt;!-- 内部圆圈的宽度 --&gt; &lt;attr name=\"nodeRadius\" format=\"dimension\" /&gt; &lt;!--内边距--&gt; &lt;attr name=\"nodePadding\" format=\"dimension\" /&gt; &lt;!--触摸有效的比例--&gt; &lt;attr name=\"touchRatio\" format=\"float\" /&gt; &lt;!-- 是否显示内部的圆圈 --&gt; &lt;attr name=\"insideNodeShow\" format=\"boolean\"/&gt; 四、框框 View LockView 的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374package com.juzisang.com.library;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.ViewGroup;import java.util.ArrayList;/** * Created by 橘子桑 on 2016/3/27. */public class LockView extends ViewGroup &#123; //画连接线的画笔 private Paint mLinePaint; //可以触摸的区域百分比 private float mTouchRatio; //线的颜色 protected int mLineColor; //先的宽度 protected float mLineWidth; //已经选中了的View ArrayList&lt;MarkerView&gt; mNodeViews = new ArrayList&lt;&gt;(); //存储密码 protected StringBuilder pawBuilder = new StringBuilder(); //当前手指触摸的x坐标 protected float x; //当前手指触摸的y坐标 protected float y; //回调 private onLockCallback mOnLockCallback; protected int mDefaultColor; protected int mSelectColor; protected int mErrerColor; //禁用手势锁 private boolean mLockScreen; private boolean isTouch; //是否把连接线绘制在子View的上面 private boolean mLineTop = false; //手指离开立即重绘 private boolean mFingerLeaveRedraw = true; public LockView(Context context) &#123; this(context, null); &#125; public LockView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LockView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(context, attrs, defStyleAttr); &#125; protected void initView(Context context, AttributeSet attrs, int defStyleAttr) &#123; TypedArray r = context.obtainStyledAttributes(attrs, R.styleable.MarkerView); boolean insideNodeShow = r.getBoolean(R.styleable.LockView_insideNodeShow, false); //默认的颜色 mDefaultColor = r.getColor(R.styleable.LockView_defaultColor, context.getResources().getColor(android.R.color.holo_blue_dark)); int mDefailtFullColor = r.getColor(R.styleable.LockView_defaultFullColor, getFullAlpha(mDefaultColor, 0.3F)); int mNodeDefaultColor = (int) r.getColor(R.styleable.LockView_defaultNodeColor, mDefaultColor); //选中的颜色 mSelectColor = (int) r.getColor(R.styleable.LockView_selectColor, context.getResources().getColor(android.R.color.holo_blue_light)); int mFrameSelectFullColor = r.getColor(R.styleable.LockView_selectFrameFullColor, getFullAlpha(mSelectColor, 0.3F)); int mNodeSelectColor = r.getColor(R.styleable.LockView_selectNodeColor, mSelectColor); //错误时候的颜色 mErrerColor = r.getColor(R.styleable.LockView_errorColor, context.getResources().getColor(android.R.color.holo_red_light)); int mErrerFullColor = r.getColor(R.styleable.LockView_errorFullColor, getFullAlpha(mErrerColor, 0.3F)); int mErrerNodeColor = r.getColor(R.styleable.LockView_errorNodeColor, mErrerColor); //圆框变的宽度 int mFrameLineWidth = (int) r.getDimension(R.styleable.LockView_frameLineWidth, DensityUtils.dip2px(context, 5)); //内圆的直径 int mNodeRadius = (int) r.getDimension(R.styleable.LockView_nodeRadius, DensityUtils.dip2px(context, 5)); //内边距 int mNodePadding = (int) r.getDimension(R.styleable.LockView_nodePadding, DensityUtils.dip2px(context, 10)); //触摸有效区域 mTouchRatio = r.getFloat(R.styleable.LockView_touchRatio, mTouchRatio); mLineColor = r.getColor(R.styleable.LockView_lineColor, mDefaultColor); mLineWidth = r.getDimension(R.styleable.LockView_lineWidth, DensityUtils.dip2px(context, 5)); r.recycle(); //设置线的颜色 mLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mLinePaint.setColor(mLineColor); mLinePaint.setStyle(Paint.Style.STROKE); mLinePaint.setStrokeWidth(mLineWidth); mLinePaint.setStrokeCap(Paint.Cap.ROUND); mLinePaint.setStrokeJoin(Paint.Join.ROUND); for (int i = 0; i &lt; 9; i++) &#123; MarkerView view = new MarkerView(context, mDefaultColor, mDefailtFullColor, mNodeDefaultColor, mSelectColor, mFrameSelectFullColor, mNodeSelectColor, mErrerColor, mErrerFullColor, mErrerNodeColor, mFrameLineWidth, mNodeRadius, mNodePadding, insideNodeShow); view.setNum(i + 1); ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); view.setLayoutParams(params); addView(view); &#125; // 清除FLAG，否则 onDraw() 不会调用，原因是 ViewGroup 默认透明背景不需要调用 onDraw() setWillNotDraw(false); &#125; public int getFullAlpha(int color, float ratio) &#123; return Color.argb((int) (Color.alpha(color) * ratio), Color.red(color), Color.green(color), Color.blue(color)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int size = Math.min(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.getSize(heightMeasureSpec)); // 测量宽度 setMeasuredDimension(size, size); for (int i = 0; i &lt; getChildCount(); i++) &#123; measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (changed) &#123; float areaWidth = (r - l - getPaddingLeft() * 2) / 3; for (int n = 0; n &lt; 9; n++) &#123; MarkerView node = (MarkerView) getChildAt(n); // 获取3*3宫格内坐标 int row = n / 3; int col = n % 3; //加上内间距 int left = (int) (getPaddingLeft() + col * areaWidth); int top = (int) (getPaddingTop() + row * areaWidth); int right = (int) (left + areaWidth); int bottom = (int) (top + areaWidth); node.layout(left, top, right, bottom); &#125; &#125; &#125; /** * 设置连接线是否绘制在子View的上面 * true 绘制在子View的上面 * false 绘制在子View的下面 * * @param isLineTop 设置连接线是否绘制在子View的上面 */ public void setLineTop(boolean isLineTop) &#123; mLineTop = isLineTop; invalidate(); &#125; /** * 设置连接线是否绘制在子View的上面 * true 绘制在子View的上面 * false 绘制在子View的下面 */ public boolean getLineTop() &#123; return mLineTop; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (getLockScreen()) &#123; invalidate(); return false; &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //恢复默认 resetDefault(); x = event.getX(); y = event.getY(); isTouch = true; break; case MotionEvent.ACTION_MOVE: x = event.getX(); // 这里要实时记录手指的坐标 y = event.getY(); MarkerView nodeView = getNodeAt(x, y); //没有选中 if (nodeView != null &amp;&amp; !nodeView.isHighLighted()) &#123; nodeView.setState(LockState.SELECT_STATE); mNodeViews.add(nodeView); //进度 if (mOnLockCallback != null) &#123; pawBuilder.setLength(0); for (MarkerView markerView : mNodeViews) &#123; pawBuilder.append(markerView.getNum()); &#125; mOnLockCallback.onProgress(pawBuilder.toString(), nodeView.getNum()); &#125; &#125; if (mNodeViews.size() &gt; 0) &#123; invalidate(); &#125; break; case MotionEvent.ACTION_UP: LogUtils.i(\"手指抬起了\"); isTouch = false; pawBuilder.setLength(0); if (mNodeViews.size() &lt;= 0) return true; pawBuilder.delete(0, pawBuilder.length()); if (mOnLockCallback != null) &#123; for (MarkerView markerView : mNodeViews) &#123; pawBuilder.append(markerView.getNum()); &#125; mOnLockCallback.onFinish(pawBuilder.toString()); &#125; if (mFingerLeaveRedraw) &#123; resetDefault(); &#125; else &#123; invalidate(); &#125; break; &#125; return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; //线画在子view的下面 if (!mLineTop) onDrawLock(canvas); &#125; //画子View的地方 protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); //放在这里的原因是，线会被子View挡到 if (mLineTop) onDrawLock(canvas); &#125; /** * 画图的方法 */ private void onDrawLock(Canvas canvas) &#123; //屏幕锁住了，只画起点到终点的 if (getLockScreen()) &#123; onDrawNodeViewLock(canvas); return; &#125; if (isTouch || mFingerLeaveRedraw) &#123; //从第一个和最后一个的连接线 onDrawNodeViewLock(canvas); //最后一个点，到手指之间的线 if (mNodeViews.size() &gt; 0) &#123; MarkerView lastNode = mNodeViews.get(mNodeViews.size() - 1); canvas.drawLine(lastNode.getCenterX(), lastNode.getCenterY(), x, y, mLinePaint); &#125; &#125; else &#123; //如果手指离开屏幕，并且设置了手指离开立即重绘 onDrawNodeViewLock(canvas); &#125; &#125; private void onDrawNodeViewLock(Canvas canvas) &#123; //从第一个和最后一个的连接线 for (int i = 1; i &lt; mNodeViews.size(); i++) &#123; MarkerView frontNode = mNodeViews.get(i - 1); MarkerView backNode = mNodeViews.get(i); canvas.drawLine(frontNode.getCenterX(), frontNode.getCenterY(), backNode.getCenterX(), backNode.getCenterY(), mLinePaint); &#125; &#125; /** * 获取给定坐标点的Node，返回null表示当前手指在两个Node之间 */ private MarkerView getNodeAt(float x, float y) &#123; for (int n = 0; n &lt; getChildCount(); n++) &#123; MarkerView node = (MarkerView) getChildAt(n); //计算触摸区域以外的距离 float ratioPadding = (node.getWidth() - (node.getWidth() * mTouchRatio)) / 2; if (!(x &gt;= node.getLeft() + ratioPadding &amp;&amp; x &lt; node.getRight() - ratioPadding)) &#123; continue; &#125; if (!(y &gt;= node.getTop() + ratioPadding &amp;&amp; y &lt; node.getBottom() - ratioPadding)) &#123; continue; &#125; return node; &#125; return null; &#125; /** * 设置连接线的颜色 * * @param color 颜色值 */ public void setLineColor(int color) &#123; mLinePaint.setColor(color); &#125; /** * 手指离开立即重绘 */ public void setfingerLeaveRedraw(boolean mFingerLeaveRedraw) &#123; this.mFingerLeaveRedraw = mFingerLeaveRedraw; &#125; public boolean getfingerLeaveRedraw() &#123; return this.mFingerLeaveRedraw; &#125; /** * 重置状态 为默认状态 */ public void resetDefault() &#123; setState(LockState.DEFAULT_COLOR); mNodeViews.clear(); &#125; /** * 重置状态错误状态 */ public void resetErrer() &#123; setState(LockState.ERRER_STATE); &#125; /** * 重置为选中状态 */ public void resetSelect() &#123; setState(LockState.SELECT_STATE); &#125; /** * 锁屏，不允许触摸 */ public void LockScreen(boolean isScreen) &#123; mLockScreen = isScreen; &#125; public boolean getLockScreen() &#123; return mLockScreen; &#125; public void setState(LockState state) &#123; switch (state) &#123; case DEFAULT_COLOR: case SELECT_STATE: setLineColor(mSelectColor); break; case ERRER_STATE: setLineColor(mErrerColor); break; &#125; int size = mNodeViews.size(); for (int i = 0; i &lt; size; i++) &#123; mNodeViews.get(i).setState(state); &#125; invalidate(); &#125; public void setLockCallback(onLockCallback lockCallback) &#123; mOnLockCallback = lockCallback; &#125; //回调 public interface onLockCallback &#123; void onProgress(String paw, int current); void onFinish(String paw); &#125;&#125; 以上注释都写的很清楚了，下面讲一下遇到的一些问题。 五、遇到的问题 画出来的线被上面的圈圈覆盖了 通过百度，知道 ViewGroup 的 onDraw 是画布局中的内容的，画子 View 的的方法在这个方法的后面执行，所以 ViewGroup 的内容会被子 View 覆盖，那么怎么才能把连接线画在子 View 的上面呢，很简单 只要在画子 View 的方法中执行就好了 123456//画子View的地方 protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); //放在这里的原因是，线会被子View挡到 if (mLineTop) onDrawLock(canvas); &#125; 下面是 View 的 draw()方法 12345678910111213141516171819202122232425262728293031323334353637@CallSuper public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children //这里就是画子View的方法了 dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; 怎么设置触摸的区域？ 123456789101112131415161718/** * 获取给定坐标点的Node，返回null表示当前手指在两个Node之间 */private MarkerView getNodeAt(float x, float y) &#123; for (int n = 0; n &lt; getChildCount(); n++) &#123; MarkerView node = (MarkerView) getChildAt(n); //计算触摸区域以外的距离 float ratioPadding = (node.getWidth() - (node.getWidth() * mTouchRatio)) / 2; if (!(x &gt;= node.getLeft() + ratioPadding &amp;&amp; x &lt; node.getRight() - ratioPadding)) &#123; continue; &#125; if (!(y &gt;= node.getTop() + ratioPadding &amp;&amp; y &lt; node.getBottom() - ratioPadding)) &#123; continue; &#125; return node; &#125; return null;&#125; 看上面代码， 根据圆圈的宽度减去可触摸区域的长度除 2，得到可触摸区域距离边框的距的距离。 光看代码看着有点圆，画个图看一下吧 画个图是不是清晰很多，只要用 getLeft+边距，和 getRight-边距，就能得到可触摸区域在 x 轴上的范围了，Y 轴同理，不懂的同学自己用笔画一下吧~ 差不多就上面两个问题了 下载地址","categories":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/tags/Android/"},{"name":"CustomView","slug":"CustomView","permalink":"https://www.juzisang.com/tags/CustomView/"}]},{"title":"JS传递数据给IOS Android","slug":"JS传递数据给IOS Android","date":"2016-04-23T16:00:00.000Z","updated":"2019-02-10T10:04:29.422Z","comments":true,"path":"passages/JS传递数据给IOS Android/","link":"","permalink":"https://www.juzisang.com/passages/JS传递数据给IOS Android/","excerpt":"最近学习 Html，需要调用传递数据到 IOS 和 Android，写博客记录下~","text":"最近学习 Html，需要调用传递数据到 IOS 和 Android，写博客记录下~ 最近学习 Html，需要调用传递数据到 IOS 和 Android，写博客记录下~ 一、判断设备是 Android 还是 IOS 12345678910111213141516171819var browser = &#123; versions: (function() &#123; var a = navigator.userAgent, b = navigator.appVersion; return &#123; trident: a.indexOf(\"Trident\") &gt; -1, presto: a.indexOf(\"Presto\") &gt; -1, webKit: a.indexOf(\"AppleWebKit\") &gt; -1, gecko: a.indexOf(\"Gecko\") &gt; -1 &amp;&amp; a.indexOf(\"KHTML\") == -1, mobile: !!a.match(/AppleWebKit.*Mobile.*/), ios: !!a.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), android: a.indexOf(\"Android\") &gt; -1 || a.indexOf(\"Linux\") &gt; -1, iPhone: a.indexOf(\"iPhone\") &gt; -1, iPad: a.indexOf(\"iPad\") &gt; -1, webApp: a.indexOf(\"Safari\") == -1 &#125;; &#125;)(), language: (navigator.browserLanguage || navigator.language).toLowerCase()&#125;; 用法： 12345if (browser.versions.android) &#123; //Android&#125; else if (browser.versions.ios) &#123; //ios&#125; 二、调用 Android 的代码 Android 这边相对 IOS 要简单很多，叫 Android 提供一个类名，方法名直接调用即可 123//这里的Android全部都是Android程序猿给你里，叫他提供这两个调用就可以了//data为传递过去的数据Android.Android(data); 三、调用 IOS 的代码 12345678910function GoIos(data) &#123; var iframe = document.createElement(\"iframe\"); var url = \"myapp:\"; url = url + \"&amp;data=\" + data; iframe.src = url; iframe.style.display = 'none'; document.body.appendChild(iframe); iframe.parentNode.removeChild(iframe); iframe = null;&#125; data 为 String 数据，传递过去，IOS 就会触发相应回调了 四、应用 123456789101112//照上面的写法，代码应该如下function GoToApp(data)&#123;//只能传递字符串，如果是JSON，转成字符串data = JSON.stringify(data);if (browser.versions.android) &#123; //Android Android.Android(data); &#125; else if (browser.versions.ios) &#123; //ios GoIos(data); &#125;&#125; 参考： js(javascript)与 ios(Objective-C)相互通信交互","categories":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/tags/Android/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.juzisang.com/tags/JavaScript/"}]},{"title":"为RecyclerView打造万能适配器，点击事件，5.0水波纹点击效果","slug":"万能适配器","date":"2016-01-01T16:00:00.000Z","updated":"2019-02-10T10:08:17.739Z","comments":true,"path":"passages/万能适配器/","link":"","permalink":"https://www.juzisang.com/passages/万能适配器/","excerpt":"最近使用到 RecyclerView，RecyclerView 使用详解戳这里，由于使用过张鸿洋大神的ListView 万能 Adapter，感觉 RecyclerView 的 Adapter 编写还是太麻烦了，而且没有点击事件，ok，参考 ListView 的万能 Adapter 的思路，写一个 RecyclerView 通用的 Adapter，在加上点击效果(￣︶￣)↗ 涨","text":"最近使用到 RecyclerView，RecyclerView 使用详解戳这里，由于使用过张鸿洋大神的ListView 万能 Adapter，感觉 RecyclerView 的 Adapter 编写还是太麻烦了，而且没有点击事件，ok，参考 ListView 的万能 Adapter 的思路，写一个 RecyclerView 通用的 Adapter，在加上点击效果(￣︶￣)↗ 涨 一、前言 最近使用到 RecyclerView，RecyclerView 使用详解戳这里，由于使用过张鸿洋大神的ListView 万能 Adapter，感觉 RecyclerView 的 Adapter 编写还是太麻烦了，而且没有点击事件，ok，参考 ListView 的万能 Adapter 的思路，写一个 RecyclerView 通用的 Adapter，在加上点击效果(￣︶￣)↗ 涨 二、代码编写 RecyclerAdapter 的编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example.admin.recyclerviewdemo;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import java.util.List;/** * Created by 橘子桑 on 2016/1/2. */public abstract class RecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;RecyclerViewHolder&gt; &#123; private Context mContext; private List&lt;T&gt; mDatas; private int mLayoutId; private LayoutInflater mInflater; private OnItemClickListener onItemClickListener; public RecyclerAdapter(Context mContext, List&lt;T&gt; mDatas, int mLayoutId) &#123; this.mContext = mContext; this.mDatas = mDatas; this.mLayoutId = mLayoutId; mInflater = LayoutInflater.from(mContext); &#125; @Override public RecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //这里是创建ViewHolder的地方，RecyclerAdapter内部已经实现了ViewHolder的重用 //这里我们直接new就好了 return new RecyclerViewHolder(mInflater.inflate(mLayoutId, parent, false)); &#125; @Override public void onBindViewHolder(RecyclerViewHolder holder, int position) &#123; &#125; public abstract void convert(RecyclerViewHolder holder, T data, int position); @Override public int getItemCount() &#123; return mDatas.size(); &#125; /**自定义RecyclerView item的点击事件的点击事件*/ interface OnItemClickListener &#123; void OnItemClickListener(View view, int position); &#125;&#125; 上面参考 ListView 的万能适配器，写的一个抽象类，可以看到 onBindViewHolder 方法里面是空的，我们需要在这里来，加入点击事件和效果。 RecyclerHolder 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.admin.recyclerviewdemo;import android.graphics.Bitmap;import android.support.v7.widget.RecyclerView;import android.util.SparseArray;import android.view.View;import android.widget.ImageView;import android.widget.TextView;/** * Created by 橘子桑 on 2016/1/2. */public class RecycleHolder extends RecyclerView.ViewHolder &#123; /** 用于存储当前item当中的View */ private SparseArray&lt;View&gt; mViews; public RecycleHolder(View itemView) &#123; super(itemView); mViews = new SparseArray&lt;View&gt;(); &#125; public &lt;T extends View&gt; T findView(int ViewId) &#123; View view = mViews.get(ViewId); //集合中没有，则从item当中获取，并存入集合当中 if (view == null) &#123; view = itemView.findViewById(ViewId); mViews.put(ViewId, view); &#125; return (T) view; &#125; public RecycleHolder setText(int viewId, String text) &#123; TextView tv = findView(viewId); tv.setText(text); return this; &#125; public RecycleHolder setText(int viewId, int text) &#123; TextView tv = findView(viewId); tv.setText(text); return this; &#125; public RecycleHolder setImageResource(int viewId, int ImageId) &#123; ImageView image = findView(viewId); image.setImageResource(ImageId); return this; &#125; public RecycleHolder setImageBitmap(int viewId, Bitmap bitmap) &#123; ImageView image = findView(viewId); image.setImageBitmap(bitmap); return this; &#125; public RecycleHolder setImageNet(int viewId, String url) &#123; ImageView image = findView(viewId); //使用你所用的网络框架等 return this; &#125;&#125; 可以看的上面代码非常的简单，就是储存了当前 item 中的 View 而已，因为 RecyclerView 内部已经实现了 ViewHolder 的重用&lt;(￣︶￣)&gt; 为 RecyclerView 添加 item 的点击事件 12345678910111213141516@Override public void onBindViewHolder(final RecycleHolder holder, int position) &#123; if (onItemClickListener != null) &#123; //设置背景 holder.itemView.setBackgroundResource(R.drawable.recycler_bg); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //注意，这里的position不要用上面参数中的position，会出现位置错乱 onItemClickListener.OnItemClickListener(holder.itemView, holder.getLayoutPosition()); &#125; &#125;); &#125; convert(holder, mDatas.get(position), position); &#125; public abstract void convert(RecycleHolder holder, T data, int position); 上面就完成了，万能适配器的编写，还有点击事件的添加了 drawable xml 代码 为了让 5.0 以上的系统产生水波纹效果，所以我们新建一个 drawable-v21 目录来存放 drawable 文件 5.0 以下 drawable 文件 recycler_bg.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"true\" &gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"#cfd8dc\"&gt;&lt;/solid&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 5.0 以上 drawable-v21 recycler_rectangle.xml recycler_bg.xml 12345&lt;!--点击出现的水波纹效果是矩形的 --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;solid android:color=\"#FFFFFF\" /&gt;&lt;/shape&gt; 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- ripple 是5.0才出现的新标签--&gt;&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"#cfd8dc\" &gt;&lt;!-- 点击出现的水波纹的颜色 --&gt; &lt;item android:drawable=\"@drawable/recycler_rectangle\"/&gt;&lt;/ripple&gt; 三、使用 写个匿名类就 OK 了 ╭(′▽`)╯ 是不是比以前简单好多 123456789101112131415161718192021@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView rv_list = findView(R.id.rv_list); rv_list.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); rv_list.setAdapter(TextAdapter = new RecyclerAdapter&lt;String&gt;(this, getData(), R.layout.recycler_item) &#123; @Override public void convert(RecycleHolder holder, String data, int position) &#123; holder.setText(R.id.tv, data); holder.setImageResource(R.id.image, R.mipmap.ic_launcher); &#125; &#125;); TextAdapter.setOnItemClickListener(new RecyclerAdapter.OnItemClickListener() &#123; @Override public void OnItemClickListener(View view, int position) &#123; ToastShow(\"点击\" + position); &#125; &#125;);&#125; 四、效果 5.0 的效果 代码下载地址 http://download.csdn.net/detail/qq_29262849/9387198","categories":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.juzisang.com/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://www.juzisang.com/tags/RecyclerView/"}]}]}